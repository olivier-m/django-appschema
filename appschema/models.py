# -*- coding: utf-8 -*-
#
# This file is part of Django appschema released under the MIT license.
# See the LICENSE for more information.

from datetime import datetime
import imp

from django.db import connection, models, transaction
from django.db.utils import DatabaseError, IntegrityError

from appschema.db import _syncdb_apps, _migrate_apps
from appschema.schema import schema_store
from appschema.south_utils import get_migration_candidates
from appschema.utils import get_apps, escape_schema_name


def new_schema(name, public_name, is_active=True, **options):
    """
    This function adds a schema in schema model and creates physical schema.
    """

    try:
        schema = Schema(name=name, public_name=public_name, is_active=is_active)
        schema.save()
    except IntegrityError:
        raise Exception('Schema already exists.')

    create_schema(name, **options)
    return schema


def create_schema(name, **options):
    """
    This function creates a schema and perform a syncdb on it.
    As we call some syncdb and migrate management commands, we can't rely on
    transaction support.
    We are going to catch any exception (including SystemExit).
    """
    try:
        cursor = connection.cursor()
        # We can't use params with system names
        cursor.execute('CREATE SCHEMA "%s"' % escape_schema_name(name))
        transaction.commit_unless_managed()
    except BaseException:
        transaction.rollback_unless_managed()
        raise

    try:
        defaults = {
            'verbosity': 0,
            'traceback': None,
            'noinput': True
        }
        defaults.update(options)

        sync_options = options
        # We never want migration to launch with syncdb call
        sync_options['migrate'] = False

        _, isolated_apps = get_apps()

        _syncdb_apps(isolated_apps, schema=name, force_close=False, **sync_options)
        _migrate_apps(get_migration_candidates(isolated_apps), schema=name, force_close=False, **options)
        schema_store.reset_path()
    except BaseException:
        transaction.rollback_unless_managed()
        drop_schema(name)
        raise


def new_schema_from_template(name, public_name, template_file, is_active=True):
    try:
        schema = Schema(name=name, public_name=public_name, is_active=is_active)
        schema.save()
    except IntegrityError:
        raise Exception('Schema already exists.')

    create_schema_from_template(name, template_file)


@transaction.commit_manually
def create_schema_from_template(name, template_file):
    """
    This function creates a new schema based on a template file. This template
    should be generated by ``schematemplate`` command (with --aspython option)
    """
    sql = imp.load_source('schema_module', template_file).schema_sql
    sql = sql % {'schema_name': '"%s"' % escape_schema_name(name)}

    cursor = connection.cursor()
    try:
        # Systems behave differently with cursor.execute()
        try:
            cursor.execute(sql)
        except IndexError:
            cursor.execute(sql.replace('%', '%%'))
        transaction.commit()
    except:
        transaction.rollback()
        raise


@transaction.commit_manually
def drop_schema(name):
    Schema.objects.filter(name=name).delete()

    cursor = connection.cursor()
    try:
        # We can't use params with system names
        cursor.execute('DROP SCHEMA "%s" CASCADE' % escape_schema_name(name))
        transaction.commit()
    except DatabaseError:
        transaction.rollback()
    except:
        transaction.rollback()
        raise


class SchemaManager(models.Manager):
    def active(self):
        return self.filter(is_active=True)


class Schema(models.Model):
    created = models.DateTimeField(default=datetime.now)
    name = models.CharField(max_length=64)
    public_name = models.CharField(max_length=255, db_index=True)
    is_active = models.BooleanField(default=True, db_index=True)

    objects = SchemaManager()

    class Meta:
        unique_together = ('name', 'public_name')

    def __unicode__(self):
        return u'%s (%s)' % (self.name, self.public_name)
