# -*- coding: utf-8 -*-
#
# This file is part of Django appschema released under the MIT license.
# See the LICENSE for more information.

from datetime import datetime
import imp

from django.conf import settings
from django.db import connection, models, transaction
from django.db.utils import DatabaseError, IntegrityError

from appschema import syncdb, migrate
from appschema.db import syncdb_apps, migrate_apps
from appschema.schema import schema_store
from appschema.south_utils import get_migration_candidates
from appschema.utils import get_apps, escape_schema_name

def new_schema(name, public_name, is_active=True, **options):
    """
    This function adds a schema in schema model and creates physical schema.
    """
    
    try:
        schema = Schema(name=name, public_name=public_name, is_active=is_active)
        schema.save()
    except IntegrityError:
        raise Exception('Schema already exists.')
    
    create_schema(name, **options)
    return schema

def create_schema(name, **options):
    """
    This function creates a schema and perform a syncdb on it.
    As we call some syncdb and migrate management commands, we can't rely on
    transaction support.
    We are going to catch any exception (including SystemExit).
    """
    try:
        cursor = connection.cursor()
        # We can't use params with system names
        cursor.execute('CREATE SCHEMA "%s"' % escape_schema_name(name))
        transaction.commit_unless_managed()
        
        defaults = {
            'verbosity': 0,
            'traceback': None,
            'noinput': True
        }
        defaults.update(options)
        
        sync_options = options
        # We never want migration to launch with syncdb call
        sync_options['migrate'] = False
        
        _, isolated_apps = get_apps()
        
        syncdb_apps(isolated_apps, name, **sync_options)
        migrate_apps(get_migration_candidates(isolated_apps), name, **options)
        schema_store.reset_path()
    except BaseException, e:
        drop_schema(name)
        raise Exception(str(e))
    

def new_schema_from_template(name, public_name, template_file, is_active=True):
    try:
        schema = Schema(name=name, public_name=public_name, is_active=is_active)
        schema.save()
    except IntegrityError:
        raise Exception('Schema already exists.')
    
    create_schema_from_template(name, template_file)

@transaction.commit_manually
def create_schema_from_template(name, template_file):
    """
    This function creates a new schema based on a template file. This template
    should be generated by ``schematemplate`` command (with --aspython option)
    """
    sql = imp.load_source('schema_module', template_file).schema_sql
    sql = sql % {'schema_name': '"%s"' % escape_schema_name(name)}
    
    cursor = connection.cursor()
    try:
        # Systems behave differently with cursor.execute()
        try:
            cursor.execute(sql)
        except IndexError:
            cursor.execute(sql.replace('%', '%%'))
        transaction.commit()
    except:
        transaction.rollback()
        raise

@transaction.commit_manually
def drop_schema(name):
    Schema.objects.filter(name=name).delete()
    
    cursor = connection.cursor()
    try:
        # We can't use params with system names
        cursor.execute('DROP SCHEMA "%s" CASCADE' % escape_schema_name(name))
        transaction.commit()
    except DatabaseError:
        transaction.rollback()
    except:
        transaction.rollback()
        raise

class SchemaManager(models.Manager):
    def active(self):
        return self.filter(is_active=True)
    

class Schema(models.Model):
    created = models.DateTimeField(default=datetime.now)
    name = models.CharField(max_length=64)
    public_name = models.CharField(max_length=255, db_index=True)
    is_active = models.BooleanField(default=True, db_index=True)
    
    objects = SchemaManager()
    
    class Meta:
        unique_together = ('name', 'public_name')
    
    def __unicode__(self):
        return u'%s (%s)' % (self.name, self.public_name)
    
